# Simulator

The physics simulation and training environment for the neural network racing project. This component handles all real-time physics calculations, collision detection, and provides the interface for reinforcement learning training.

## Overview

The simulator is implemented in C for maximum performance, allowing hundreds or thousands of car instances to run in parallel during training. It reads track files generated by the track drawer and simulates realistic car physics including acceleration, steering, and collision detection.

## Current Status

**In Development** - The track drawer component is currently being built. The C simulator implementation will follow.

## Architecture

```
simulator/
├── track_drawer/          # Python tool for creating tracks
│   ├── bezier.py         # Bézier curve implementation
│   ├── point.py          # Point class with vector operations
│   ├── boundary.py       # Track boundary calculation
│   ├── file_io.py        # Track file save/load
│   └── interactive_builder.py  # GUI for track creation
└── [C implementation to be added]
```

## Track Drawer

The track drawer is a Python-based tool that allows interactive creation of racing tracks using cubic Bézier curves.

### Features

- Interactive point-and-click interface for placing control points
- Cubic Bézier curves (4 control points per segment) for smooth, controllable tracks
- Automatic boundary generation from centerline
- Arc-length parameterization for uniform point spacing
- Real-time visualization of track and boundaries

### Track Format

Tracks are saved as `.txt` files with the following format:

```
WIDTH 5.0
SEGMENTS 2

SEGMENT 0
CONTROL_POINTS 4
0.0 0.0
2.0 5.0
8.0 5.0
10.0 0.0

SEGMENT 1
CONTROL_POINTS 4
10.0 0.0
12.0 -3.0
18.0 -3.0
20.0 0.0

LEFT_BOUNDARY 200
0.0 2.5
0.1 2.6
...

RIGHT_BOUNDARY 200
0.0 -2.5
0.1 -2.4
...
```

### Creating a Track

1. Run the track drawer tool
2. Click to place 4 control points for the first segment (start, control1, control2, end)
3. Click to place 3 control points for subsequent segments (control1, control2, end)
   - The start point is automatically the previous segment's end point
4. Press `ESC` to undo the last point
5. Press `ENTER` when finished to save the track

### Technical Details

**Bézier Curves:**
- Uses De Casteljau's algorithm for curve evaluation
- Cubic Bézier (4 control points) provides smooth, controllable curves
- Segments connect end-to-end to form complete tracks

**Arc-Length Sampling:**
- Approximately 100 points per segment
- Points are evenly spaced by distance (not parameter value)
- Ensures consistent spacing for accurate simulation and collision detection

**Boundary Calculation:**
- Calculated perpendicular to the centerline tangent vector
- Left boundary: centerline + normal × (width/2)
- Right boundary: centerline - normal × (width/2)
- Constant width throughout the track

## Physics Simulation (C Implementation - To Be Built)

The C simulator will implement the following:

### Input to Neural Network

- **Ray casts**: Distance sensors to track boundaries (number TBD, typically 5-7)
- **Current speed**: Scalar value
- **Current acceleration**: Scalar value  
- **Current steering angle**: Scalar value
- All inputs normalized to consistent range

### Output from Neural Network

- **Change in acceleration (Δa)**: Bounded to reasonable range
- **Change in steering angle (Δθ)**: Bounded to reasonable range

### Starting Conditions

- **Position**: Start line with slight left-right variation
- **Speed**: 0 (stationary)
- **Steering angle**: Slight variation (±5-10°)
- **Randomization**: Fixed seed or pre-generated positions for deterministic training

### Episode Termination

An episode ends when:
- Car goes off track (outside boundaries)
- Car collides with track boundary
- No movement for 3 consecutive seconds (distance moved < threshold)
- Optional: Maximum time limit reached

### Reward Function

**Primary reward**: Distance traveled from start along the track

**Implementation**:
- Pre-compute cumulative distance for each track point
- Track the furthest point reached (by index)
- Only update progress when car is on track
- Reward = distance of furthest point when episode terminates

### Physics Model

**To be specified:**
- Timestep (dt)
- Integration method (Euler recommended for consistency)
- Car dimensions
- Friction model
- Acceleration model
- Steering response

All physics parameters will be documented in detail to ensure identical implementation across language ports.

## Performance Targets

**C Implementation:**
- Target: ~1000 concurrent simulations
- Fast episode generation for efficient training
- Minimal memory footprint per instance

## Collision Detection

**Method**: Check if car position is within track boundaries
- Compare car position against left and right boundary points
- Efficient spatial lookup using pre-computed track structure
- Binary search or spatial hashing for large tracks

## Integration with Neural Networks

The simulator provides a clean interface for reinforcement learning:

1. **Initialize**: Load track, create car instances
2. **Step**: Given network outputs (Δa, Δθ), update physics and return new state
3. **Reset**: Return car to start with randomized initial conditions
4. **Terminate**: Signal episode end and return final reward

The neural network implementations (Python, C, Java) will interface with the C simulator for training.

## File Locations

**Track files**: `simulator/tracks/`
- Example: `track_001.txt`, `track_002.txt`

**Track drawer code**: `simulator/track_drawer/`

**C simulator code**: To be added

## Dependencies

**Track Drawer (Python):**
- numpy
- matplotlib (for interactive GUI)

**C Simulator:**
- Standard C libraries only
- No external dependencies for maximum portability

## Development Status

- [x] Track drawer design
- [x] Bézier curve implementation
- [x] Point class with vector operations
- [x] Boundary calculation
- [x] File I/O
- [x] Interactive GUI
- [ ] C simulator physics engine
- [ ] Collision detection
- [ ] Neural network interface
- [ ] Multi-instance parallelization

## Next Steps

1. Complete track drawer implementation
2. Create several test tracks
3. Design C simulator architecture
4. Implement core physics loop
5. Add collision detection
6. Create neural network interface
7. Implement parallel instance management

## Notes

The simulator is designed to be deterministic and consistent. The same track file and initial conditions should produce identical results across multiple runs, enabling fair comparison of different neural network implementations and training approaches.